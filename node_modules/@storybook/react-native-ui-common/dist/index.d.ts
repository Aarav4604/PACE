import * as react from 'react';
import { ReactElement, FC, PropsWithChildren, ReactNode, SyntheticEvent, DependencyList, Dispatch, useState } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as _storybook_react_native_theming from '@storybook/react-native-theming';
import { Theme } from '@storybook/react-native-theming';
import * as react_native from 'react-native';
import { TouchableOpacityProps, PressableProps, ViewStyle, TextStyle, ImageStyle, StyleProp } from 'react-native';
import { StoryContext, Args } from 'storybook/internal/csf';
import { ReactRenderer } from '@storybook/react';
import * as Fuse from 'fuse.js';
import { State, StoriesHash, API, IndexHash } from 'storybook/internal/manager-api';
import { StatusesByStoryIdAndTypeId, StatusValue, API_IndexHash, API_PreparedStoryIndex, StoryIndexV2, StoryIndexV3, API_Provider, DocsOptions } from 'storybook/internal/types';

interface ButtonProps extends TouchableOpacityProps {
    asChild?: boolean;
    size?: 'small' | 'medium';
    padding?: 'small' | 'medium';
    variant?: 'outline' | 'solid' | 'ghost';
    disabled?: boolean;
    active?: boolean;
    animation?: 'none' | 'rotate360' | 'glow' | 'jiggle';
    text?: string;
    Icon?: (props: {
        color: string;
    }) => ReactElement;
}
declare const Button: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<any>>;
declare const ButtonText: _storybook_react_native_theming.StyledComponent<react_native.TextProps & {
    theme?: _storybook_react_native_theming.Theme;
    as?: React.ElementType;
} & {
    variant: ButtonProps["variant"];
    active: ButtonProps["active"];
}, {}, {
    ref?: react.Ref<react_native.Text>;
}>;
declare const ButtonIcon: ({ Icon, active, variant, }: {
    Icon: (props: {
        color: string;
    }) => ReactElement;
    variant: ButtonProps["variant"];
    active: ButtonProps["active"];
}) => react_jsx_runtime.JSX.Element;

declare const IconButton: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<unknown>>;

type LayoutContextType = {
    isDesktop: boolean;
    isMobile: boolean;
};
declare const LayoutProvider: FC<PropsWithChildren>;
declare const useLayout: () => LayoutContextType;

interface Storage {
    getItem: (key: string) => Promise<string | null>;
    setItem: (key: string, value: string) => Promise<void>;
}
declare const StorageProvider: FC<PropsWithChildren<{
    storage: Storage;
}>>;
declare const useStorage: () => Storage;

type Refs = State['refs'];
type RefType = Refs[keyof Refs] & {
    allStatuses?: StatusesByStoryIdAndTypeId;
};
type Item = StoriesHash[keyof StoriesHash];
type Dataset = Record<string, Item>;
interface CombinedDataset {
    hash: Refs;
    entries: [string, RefType][];
}
interface ItemRef {
    itemId: string;
    refId: string;
}
interface StoryRef {
    storyId: string;
    refId: string;
}
type Highlight = ItemRef | null;
type Selection = StoryRef | null;
declare function isExpandType(x: any): x is ExpandType;
interface ExpandType {
    showAll: () => void;
    totalCount: number;
    moreCount: number;
}
type SearchItem = Item & {
    refId: string;
    path: string[];
    status?: StatusValue;
    showAll?: () => void;
};
type SearchResult = Fuse.FuseResult<SearchItem>;
type SearchResultProps = SearchResult & {
    icon: string;
    isHighlighted: boolean;
    onPress: PressableProps['onPress'];
};
type GetSearchItemProps = (args: {
    item: SearchResult;
    index: number;
    key: string;
}) => SearchResultProps;
type SearchChildrenFn = (args: {
    query: string;
    results: SearchResult[];
    isBrowsing: boolean;
    closeMenu: (cb?: () => void) => void;
    getItemProps: GetSearchItemProps;
    highlightedIndex: number | null;
}) => ReactNode;
type SBUI = (props: {
    story?: StoryContext<ReactRenderer, Args>;
    storyHash: API_IndexHash;
    setStory: (storyId: string) => void;
    storage: Storage;
    theme: Theme;
    children: ReactElement;
}) => ReactElement;

type ToStoriesHashOptions = {
    provider: API_Provider<API>;
    docsOptions: DocsOptions;
    filters: State['filters'];
    allStatuses: StatusesByStoryIdAndTypeId;
};
declare const intersect: <T>(a: T[], b: T[]) => T[];
declare const merge: <TObj = any>(a: TObj, ...b: Partial<TObj>[]) => TObj;
declare const noArrayMerge: <TObj = any>(a: TObj, ...b: Partial<TObj>[]) => TObj;
declare const transformStoryIndexToStoriesHash: (input: API_PreparedStoryIndex | StoryIndexV2 | StoryIndexV3, { provider, docsOptions, filters, allStatuses }: ToStoriesHashOptions) => API_IndexHash | any;
declare const transformStoryIndexV2toV3: (index: StoryIndexV2) => StoryIndexV3;
declare const transformStoryIndexV3toV4: (index: StoryIndexV3) => API_PreparedStoryIndex;
declare const transformStoryIndexV4toV5: (index: API_PreparedStoryIndex) => API_PreparedStoryIndex;

declare const createId: (itemId: string, refId?: string) => string;
declare const prevent: (e: SyntheticEvent) => boolean;
declare const get: (id: string, dataset: Dataset) => Item;
declare const getParent: (id: string, dataset: Dataset) => Item;
declare const getParents: (id: string, dataset: Dataset) => Item[];
declare const getAncestorIds: (data: IndexHash, id: string) => string[];
declare const getDescendantIds: (data: IndexHash, id: string, skipLeafs: boolean) => string[];
declare function getPath(item: Item, ref: RefType): string[];
declare const searchItem: (item: Item, ref: RefType) => SearchItem;
declare function cycle<T>(array: T[], index: number, delta: number): number;
declare const getStateType: (isLoading: boolean, isAuthRequired: boolean, isError: boolean, isEmpty: boolean) => "auth" | "error" | "loading" | "empty" | "ready";
declare const isAncestor: (element?: Element, maybeAncestor?: Element) => boolean;
declare const removeNoiseFromName: (storyName: string) => string;
declare const isStoryHoistable: (storyName: string, componentName: string) => boolean;

/**
 * A hook to memoize a style. Uses `ViewStyle` per default, but can be used with other styles deriving from `FlexStyle` as well, such as `TextStyle`.
 * @param styleFactory The function that returns a style
 * @param deps The dependencies to trigger memoization re-evaluation
 * @see ["Memoize!!! ðŸ’¾ - a react (native) performance guide"](https://gist.github.com/mrousavy/0de7486814c655de8a110df5cef74ddc)
 * @example
 *
 * // simple object styles
 * const style1 = useStyle(() => ({ height: someDynamicValue }), [someDynamicValue])
 *
 * // array styles
 * const style2 = useStyle(
 *   () => [styles.container, props.style, { height: someDynamicValue }],
 *   [props.style, someDynamicValue]
 * );
 */
declare const useStyle: <TStyle extends ViewStyle | TextStyle | ImageStyle, TOutput extends StyleProp<TStyle>>(styleFactory: () => TOutput, deps?: DependencyList) => TOutput;

type ExpandedState = Record<string, boolean>;
interface ExpandAction {
    ids: string[];
    value: boolean;
}
interface ExpandedProps {
    refId: string;
    data: StoriesHash;
    initialExpanded?: ExpandedState;
    rootIds: string[];
    selectedStoryId: string | null;
    onSelectStoryId: (storyId: string) => void;
}
declare const useExpanded: ({ refId, data, initialExpanded, rootIds, selectedStoryId, }: ExpandedProps) => [ExpandedState, Dispatch<ExpandAction>];

declare const useLastViewed: (selection: Selection) => {
    getLastViewed: () => any[];
    clearLastViewed: () => void;
};

declare const useStoreBooleanState: (key: string, defaultValue: boolean) => ReturnType<typeof useState<boolean>>;

export { Button, ButtonIcon, ButtonProps, ButtonText, CombinedDataset, Dataset, ExpandAction, ExpandType, ExpandedProps, ExpandedState, GetSearchItemProps, Highlight, IconButton, Item, ItemRef, LayoutProvider, RefType, Refs, SBUI, SearchChildrenFn, SearchItem, SearchResult, SearchResultProps, Selection, Storage, StorageProvider, StoryRef, createId, cycle, get, getAncestorIds, getDescendantIds, getParent, getParents, getPath, getStateType, intersect, isAncestor, isExpandType, isStoryHoistable, merge, noArrayMerge, prevent, removeNoiseFromName, searchItem, transformStoryIndexToStoriesHash, transformStoryIndexV2toV3, transformStoryIndexV3toV4, transformStoryIndexV4toV5, useExpanded, useLastViewed, useLayout, useStorage, useStoreBooleanState, useStyle };
